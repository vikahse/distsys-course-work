
1. Не более одного раза (at most once). Каждое сообщение от S должно быть или доставлено R ровно один раз или не доставлено вовсе.
Иными словами, нельзя допускать повторные доставки сообщений.

В этом способе доставки сообщений я применила механизм генерации уникальных идентификаторов сообщений, 
чтобы обойти ошибки DELAYED + DUPLICATED. То есть отправитель при отправке сообщения генерирует уникальный 
id и сохраняет его вместе с самим сообщением и отправляет его. Если получатель получил сообщение, то в 
первую же очередь он проверяет, было ли уже доставлено сообщение с таким идентификатором. 
Если да, то сообщение является дубликатом и игнорируется. Если сообщение является новым, 
то получатель обрабатывает его и запоминает ключ. Таким образом, сообщение будет доставлено ровно один раз или не доставлено вовсе. 

2. Не менее одного раза (at least once). Каждое сообщение от S должно быть доставлено R, при этом допускаются повторы.

Какому плану я следовала:

1. Sender отправляет сообщение получателю c уникальным ключом и заводит таймер с названием уникального ключа.
2. Receiver получает сообщение и отправляет подтверждение о его получении обратно отправителю.
3. Sender ждет подтверждения от получателя.
4. Если Sender не получает подтверждения в течение 3 секунд, он повторно отправляет сообщение и ставит таймер.
5. Получатель получает повторно отправленное сообщение и отправляет подтверждение о его получении обратно отправителю.
6. Процесс повторяется до тех пор, пока Sender не получит подтверждение от получателя и не остановит таймер.


3. Ровно один раз (exactly once). Каждое сообщение от S должно быть доставлено R ровно один раз, то есть повторы не допускаются.

То же самое, что и в (at least once), только в Receiver в методе on_message() мы проверяем, 
что если у нас уже есть полученный уникальный ключ в списке, то мы просто опять отправляем сообщение отправителю с подтверждением, 
а в предыдущем методе допускались повторы и мы не проверяли, что такое сообщение уже было получено Receiver.

4. Ровно один раз и с сохранением порядка (exactly once + ordered). Каждое сообщение от S должно быть доставлено
R ровно один раз и в порядке их отправки S.

Чтобы гарантировать правильный порядок доставки сообщений в Receiver я храню индекс последнего пришедшего сообщения. Если сообщение
с уникальным кодом еще не было обработано и его порядковый номер на единицу больше последнего пришедшего сообщения, то получатель запоминает
новый индекс и сообщает о доставке отправителю как в прошлых методах. Если сообщение с уникальным кодом не было обработано, но его порядковый номер 
не является следующим, то Receiver отправляет сообщение Sender с типом 'retry', чтобы он ему отправил заново сообщения, начиная с порядкового номера
на единицу больше, чем последний сохраненный индекс, до индекса, с которым пришло данное сообщение. По сути получатель проверяет, были ли сообщения 
доставлены в правильном порядке. Если получатель обнаруживает, что сообщение было доставлено в неправильном порядке, он может запросить
повторную отправку сообщений, которые были доставлены раньше.
