Для начала опишу поля, которые я добавила:

self._delivered - это список BCAST сообщений, которые дошли до процесса, он нужен, чтобы повторно больше на распространять BCAST сообщения среди остальных процессов; 

self._pending - это словарь, в котором для каждого сообщения я храню список процессов, от которых было получено сообщение, то есть sender так же его в свою очередь получил, этот словарь отвечает за подтверждения от процессов о
получение конретного сообщения; 

self._locals - это список доставленных локально сообщений процессом; 

self._waiting - это словарь, где по идентификатору сообщения мы достаем сообщение целиком, которое ожидает своей отправки локально для обеспечения Causal Order; 

self._count - это счетчик сообщений, которые процесс получил локально в SEND, он нужен, чтобы id сообщений выглядели следующим образом <self._count>:<self._id>, я так генерирую id сообщения, чтобы обойти Duplication; 

self._own_send_index - это поле, которое необходимо будет при реализации алгоритма по достижению гарантии Casual Order (далее подробнее); 

self._clock - массив длины, равной количеству процессов, который так же будет использоваться в алгоритме по достижению гарантии Casual Order. 

Чтобы обойти дубликацию сообщений я каждому присваиваю уникальный id и проверяю по id, что его нет в self._locals. Гарантии No Creation, Validity достигаются за счет того, что при обработке BCAST сообщения в on_message() мы проверяем, что если оно раньше не было получено и мы не являемся отправителем, то отправляем его всем процессам. Для достижения гарантии Uniform Agreement я проверяю, что сообщение еще не было отправлено локально (все по id) и что количество процессов, от которых пришло подтверждение о получении данного сообщения больше половины. Делаю я такое предположение, так как если сообщение смогло дойти до большей части процессов, значит сообщение будет в конце концов доставлено каждым корректным процессом, к тому же тем самым мы избегаем повторной бесконечной отправки подтверждения. Для достижения Causal Order я воспользовалась уже существующим алгоритмом Birman Schiper Stephenson Protocol (https://www.geeksforgeeks.org/birman-schiper-stephenson-protocol/), немного оптимизировав его. Суть алгоритма в том, что каждому сообщению мы присваиваем timestamp, равный массиву clock процесса, который начал его распространять. В массиве clock j-ый процесс увеличивает на единицу i-ый элемент, если ему пришло сообщение в SEND (в данном случае i = j) или если ему удалось локально доставить сообщение от i-го процесса. Оптимизация алгоритма заключается в том, что мы контролируем момент, если мы являемся main_sender-ом сообщения, так как нам нужно доставлять у себя локально их в том порядке, в котором мы их получали изначально. Это я контролирую тем, что у меня есть как раз поле self._own_send_index, который отвечает за порядковый номер доставленного локально сообщения, владельцем которого  является процесс. Когда i-ый процесс обрабатывает свое сообщение, то он проверяет, если в timestamp сообщения на i-ый позиции стоит следующий порядковый номер по сравнению с self._own_send_index, то мы спокойно доставляем это сообщение, иначе пока кладем в self._waiting буффер. Так же обращаем внимание при обработке не своего сообщения, что в timestamp на i-ой позиции должен стоят номер не больше, чем наш self._own_send_index, так как иначе сообщение на временной шкале было получено позже и что мы еще не все свои сообщения успели доставить. После подобных измений мы каждый раз проверяем, можем ли мы что-то уже достать из буффера self._waiting. Остальные проверки алгоритма BSS остаются неизменными.
