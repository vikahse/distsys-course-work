1. Сначала я реализовала messenger.proto, который лежит в папке messenger/proto/. Тут реализован интерфейс взаимодействия с сервером в соотвествии с требованиями. В сервисе MessengerServer я реализовала два метода SendMessage и ReadMessages, для полей вызова и ответа которых я прописала сообщения со своими определенными полями. Так же в этой папке лежат сгенерированные файлы после компиляции прото файла.
2. Затем я реализовала сервер, который лежит в папке messenger/server. Тут реализовн класс MessengerServer, в котором как раз описаны методы SendMessage и ReadMessages. В SendMessage я принимаю сообщение, запомниаю его и отправляю SendResponse с соотвествующей проставленной Timestamp. В ReadMessages я даю клиенту номер, равный количеству сообщений в списке self.messages, чтобы понимать с какого момента нужно отправлять сообщения клиенту, чтобы не отправить ему те, которые были до его прихода. После этого сервер переходит по сути в активное ожидание и постоянно проверяет наличие новых сообщений. В методе serve(), который везде встречается в примерах реализованных сервисов, мы создаем объект сервера с использованием многопоточного исполнителя, который позволяет обрабатывать несколько запросов одновременно, добавляем нашу реализацию сервиса MessengerServer, устанавливаем порт для прослушивания подключений от клиентов по адресу 0.0.0.0:$MESSENGER_SERVER_PORT, запускаем сервер и находимся в активном ожидании сигнала прерывания.
3. Потом я описала messenger/server.dockerfile, messenger/client.dockerfile, requirements.txt для своего сервера и клиента. Делала по шаблону, которогый взяла из client.dockerfile из templates.
4. И последним я реализовала клиента,который лежит в папке messenger/client (шаблон так же взяла из templates). Там необходимо было создать grpc клиента по определенному адресу, то есть я создала экземпляр клиентского объекта Stub - MessengerServerStub для взаимодействия с сервером, используя указанный адрес grpc_server_address. Потом я создаю новый поток выполнения thread, который вызывает функцию messages_stream с аргументами stub и postbox, чтобы принимать поток сообщений между клиентом и сервером и сохранять сообщения в postbox. В функции messages_stream после получения сообщения я преобразую timestamp в str, чтобы в дальнейшем это сообщение можно было преобразовать в строку формата JSON. И в методе _send_message тоже заполнила пропуски по требованию.
