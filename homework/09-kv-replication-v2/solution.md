Глобально я внедрила векторы версий. Например, когда в on_local_message приходит сообщение в ноду, которая не является нодой из списка реплик, то я начинаю поиск координатора (сначала это первая нода из списка реплик, затем если она не отвечает, то срабатывает соответствующий таймер, который отправляет запрос следующей реплике в списке), после чего с сообщениями PUT/GET так же отправляю вектор версии. При запросе PUT, если такой ключ уже был в self._data, то мы обновляем вектор версии по правилу (следовала по слайдам с лекции) в функции update_version_vector: flag_younger это V <= V’, соотвественно, если flag_younger and context != my_vector, то это соответствует случаю, когда V < V’, где local=>update и применяем значение, иначе если not flag_younger and not flag_older, то это V || V’, то есть возникает конфликт, когда мы объединяем значения. 
В PUT_CHECK добавила проверку, что если после update_version_vector значения отличаются, то отправляю PUT_CHECK тому, от кого пришло сообщение, так как у него устаревшая версия. В PUT_RETURN/GET_RETURN после обновления вектора версий проверяем, если пришедший вектор версий старше нашего, то сохраняем его в качестве будущего ответа. Для тестов с корзиной в PUT в on_local_message все значения разделяю по запятой, при отправке PUT_RESP/GET_RESP сливаем их обратно с помощью join. Из промежуточных изменений я еще храню в quorum_put/quorum_get количество нод по более сложному ключу, чтобы различать старые запросы от новых. Например, если в PUT_RETURN пришло более старое сообщение, которое было уже обработано, то я отправляю этой ноде PUT_CHECK сообщение, чтобы она сверила свои значения. 
