# Время, модели согласованности и разрешение конфликтов

В рамках данного материала мы затронем вопрос измерения времени в распределенных системах,
гарантии моделей согласованности и подходы для разрешения конфликтов.

## Время и часы

### Несовершенство физических часов

Мы обращаемся к времени очень часто: нам нужно понимать, какое событие произошло раньше,
какая версия объекта является более новой, и в основе многих алгоритмов лежат таймауты.

И как правило мы опираемся на показания физических часов, измеряющих число прошедших секунд, но эти часы несовершенны...
Часы на разных узлах показывают разное время. Более того, часы на одном компьютере могут "идти" с разной скоростью в зависимости от температуры, фазы луны и многих других факторов.

Для часов можно определить скорость дрейфа (clock drift) относительно показания других часов. Эта величина измеряется в ppm (parts per million): точность N ppm означает, что за миллион тактов разница часов составит не более N тактов. Например, при точности 40 ppm разница показаний за год составит не более `365 * 24 * 60 * 0.000040 = 21` минуту.

Человечество придумало много подходов для генерации временных тактов. Стандартная точность для популярных [кварцевых часов](https://en.wikipedia.org/wiki/Crystal_oscillator) составляет 20 - 50 ppm. Существует и более точный подход: [атомные часы](https://en.wikipedia.org/wiki/Atomic_clock) (atomic clock) измеряют периоды излучения атома цезия-133 с ppm `1e-14` (1 секунда в 3 миллиона лет). Атомные часы достаточно дорогие и их устанавливают в GPS спутниках.

Чтобы держать разницу показаний часов в допустимных границах, часы необходимо синхронизировать друг с другом. Одним из популярных протоколов для синхронизации времени считается [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) (network time protocol). Узлы системы выстраиваются в древовидную структуру, в самом верху &mdash; узлы с наиболее точными часами (reference clock). Остальные узлы общаются со своими соседями и выравнивают свое время относительно, учитывая время, затрачиваемое на сетевые походы. 

![NTP stratums](img/ntp-stratum.png)

Однако NTP не позволяет достичь идеальной синхронизации часов и вполне разумным считается отставание времени на разных серверах в пределах 1 &ndash; 100 миллисекунд, что в некоторых случаях неприемлемо много.

Инженеры Google при разработке глобально-распределенной базы данных [Spanner](https://dl.acm.org/doi/pdf/10.1145/2491245) пошли дальше: разработали TrueTime API, которое позволяет синхронизировать время с большей точностью. В каждом датацентре Google находятся атомные часы, к которым обращаются сервера из этого датацентра для синхронизации локального времени. Более того, показания атомных часов синхронизируются через GPS спутники. Также API предоставляет необычную модель получения времени: когда происходит запрос времени, возвращается не один показатель, а два: гарантируется, что актуальное показание часов находится в диапазоне `[earliest; latest]`. Размер временного отрезка как правило не превышает 7 мс.

![Google time](img/google-time.jpeg)

### Логические часы Лэмпорта

Мы поняли, что показателям физического времени доверять нельзя. Но если вспомнить, что мы хотели использовать показания времени для упорядочивания событий в системе,
можно попробовать отказаться от физического времени в угоду **логического**.

Попробуем построить частичный порядок событий, с помощью которого мы будем понимать, какое событие произошло раньше другого. Для выстраивания такой связи нам не нужно знать физическое время, когда произошло событие, достаточно уследить за логической связью.

Введем **частичное** отношение *happened before*: событие $A$ произошло до события $B$ ($A \to B$), если выполняется одно из условий:
- $A$ и $B$ произошли на одном узле, и $A$ произошло раньше (мы можем уследить за этим в рамках одного узла);
- если $A$ это отправка сообщения некоторым узлом $N_1$, а $B$ это событие получения данного сообщения некоторым узлом $N_2$;
- существует событие $C$, что $A \to C$ и $B \to C$ (транзитивность).

![Happened before schema](img/happened-before.png)

Возможна ситуация, когда $a$ и $b$ несравнимы: не выполняется ни $a \to B$, ни $b \to A$. Тогда события считаются параллельными (concurrent): $A \parallel B$. 

Именно эту идею [использует](https://lamport.azurewebsites.net/pubs/time-clocks.pdf) Leslie Lamport для логических часов (которые позже назовут часы Лэмпорта).

Введем функцию $C(a)$, которая назначает каждому событию $a$ в системе число &mdash; логический таймстемп, когда данное событие было создано. От этой функции мы хотим следующее: 

$$a \to b \implies C(b) < C(b)$$ 

То есть, если $b$ логически следует из $a$, то таймстемп $b$ больше таймстемпа $a$.

Для определения такой функции на каждом узле в нашей системе будем поддерживать числовой счетчик времени, который будет увеличиваться при наступлении нового события:
- Изначально счетчик на каждом узле равен 1.
- Когда на узле генерируется локальное событие, счетчик увеличивается на 1 и полученное число назначается таймстемпом события.
- Когда узел $N_1$ получает некоторое сообщение от другого узла $N_2$, локальный счетчик $N_1$ обновляется по правилу: $C_{N_1} = \max(C_{N_1}, C(msg)) + 1$, где $C(msg)$ равен таймстемпу события в полученном сообщении. 

Последнее правило гарантирирует следующее: таймстемп события "сообщение доставлено" будет больше таймстемпа события "сообщение отправлено".

![Lamport timeline](img/lamport-timeline.png)

Отлично. Храня один локальный счетчик на каждом узле и рядом с каждым сообщением, мы научились определять, какие события произошли раньше других.

Однако есть существенный недостаток: единственная гарантия, предоставляемая данным порядком, это $a \to b \implies C(a) < C(b)$. 

Если $C(a) < C(b)$, это в том числе может сигнализировать о $a \parallel b$. Например, в случае, когда $a$ и $b$ это локальные события на разных узлах.

Более того, $C(a) = C(b)$ не гарантирует, что $a = b$. Уникальность событий можно получить, добавив к таймстемпу номер узла, где было создано данное событие: пара $\{C(e), node_e\}$ уникально идентифицирует событие и пары можно сравнивать покомпонентно, не теряя happens before. 

### Векторные часы

Расширив идею часов Лэмпорта, можно получить векторные часы, которые предоставляют больше гарантий.

На каждом узле будем хранить вектор из N числовых значений ($N$ &mdash; число узлов в системе). Как можно догадаться, $i$-ое значение в векторе будет соответствовать логическому таймстемпу узла $i$ по мнению текущего узла:
- Изначально все значения в локальном векторе $V$ равны 0, кроме одного: $V[i] = 1$, где $i$ это номер узла.
- Когда на узле $i$ создается новое событие, необходимо сделать $V[i] = V[i] + 1$.
- Когда узел $P$ отправляет сообщение $m$ на узел $Q$, необходимо обновить счетчик узла $Q$: $V_Q[i] = \max(V_Q[i], m.V[i]) \ \forall i$ и после этого $V_Q[Q] = V_Q[Q] + 1$. Полученный вектор назначается таймстемпом события "сообщение получено".

Как можно заметить, логика обновления счетчиков очень похожа на логику обновления в часах Лэмпорта. 

![Vector clock timeline](img/vector-clock.png)

Сравнение векторов происходит покомпонентно:
- $V_a = V_b \iff V_a[i] = V_b[i] \ \ \forall i \in \{1, 2, \dots, n\}$
- $V_a \leqslant V_b \iff V_a[i] \leqslant V_b[i] \ \ \forall i \in \{1, 2, \dots, n\}$
- $V_a < V_b \iff V_a \leqslant V_b \land V_a \neq V_b$
- $V_a \parallel V_b \iff V_a \not \leqslant V_b \land V_b \not \leqslant V_a$

Благодаря таким часам, знак $\implies$ из утверждений про часы Лэмпорта можно заменить на $\iff$:
- $V(a) < V(b) \iff a \to b$
- $V(a) = V(b) \iff a = b$
- $V(a) \parallel V(b) \iff a \parallel b$

Отдельно обратим внимание, теперь если $V(a) < V(b)$, то мы наверняка можем быть уверены, что событие $a$ произошло до события $b$.

Недостатком векторных часов является его размер. Вместе с сообщением теперь необходимо "таскать" вектор, размер которого линейно зависит от числа участников в системе. Если в системе тысячи узлов, а типичное сообщение имеет размер 100 байт, мы существенно увеличим накладные расходы. В качестве оптимизации, можно не хранить нулевые значения (превратить вектор в map) и добавить процесс синхронизации узлов, в рамках которого все узлы будут обнулять оговоренные счетчики.

Идея векторных часов используется в Amazon Dynamo:

![Dynamo vector clock](img/dynamo-vector.png)

*Пояснение к иллюстрации можно найти во второй половине секции 4.4 [оригинальной статьи](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf)*.

## Модели согласованности

## Разрешение конфликтов

TBD

## Дополнительные материалы

- [TrueTime API](https://sookocheff.com/post/time/truetime/)
- [Spanner, TrueTime & The CAP Theorem](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/45855.pdf)
- [Living without atomic clocks: Where CockroachDB and Spanner diverge](https://www.cockroachlabs.com/blog/living-without-atomic-clocks/)
- [Time, Clocks, and the Ordering of Events in a Distributed System]()
- [Timestamps in Message-Passing Systems That Preserve the Partial Ordering](http://cs.engr.uky.edu/~manivann/cs570/Fidge.pdf)